Starting weekly assessment for Eva, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 1.46 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week1, Assessment, Week2, .git

Found the following files in parent directory: README.md

Checking for key files in parent directory...

.gitignore missing, 1 pt deducted

Current Points = 99

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# Title: CMEE Coursework Repository
# Author: Eva Linehan
# Date: Oct 2018

The purpose of this repository is to store CMEE required coursework for assessment. Coursework is organised by Week, for example coursework for week one will reside in the "Week1" folder. 

In each "Week" folder, coursework is arranged in the 'Data', 'Code', 'Sandbox' and 'Results' folders. The 'Data' folder comprises of data files used in practical exercises and assessments during the week. 'Code' contains code used to execute commands as part of in-class examples and weekly assessments. The 'Sandbox'folder is primarily for storing output files from test examples and the 'Results' folder will contain output files when scripts in 'Code' are executed.



 
**********************************************************************

======================================================================
Looking for the weekly directories...

Found 2 weekly directories: Week1, Week2

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: Code, Data, Sandbox, Results

Found the following files: .gitignore, README

Checking for readme file in weekly directory...

Found README in parent directory, named: README

Printing contents of README:
**********************************************************************
# Title: CMEE Coursework Week 2
# Author: Eva Linehan
# Date: Oct 2018

This folder contains CMEE coursework from week 1 arranged in the 'Data', 'Code' and 'Sandbox' folders. The 'Data' folder comprises of data files used in practical exercises and assessments during the week. 'Code' contains code used to execute commands as part of in-class examples and weekly assessments. The 'Sandbox'folder is primarily for storing output files from practical examples.

This week's coursework comprises of the following chapters of the "Multilingual Quantitative Biologist!" notebook;
Chapter 6: Biological Computing in Python-I
.
├── Code
│   ├── align_seqs.py : Aligning DNA sequences and assigning a score based on the start position and number of base matches. 
│   ├── basic_csv.py : Importing, reading and writing .csv files in python. 
│   ├── basic_io.py : Example of printing input files, generating output files and storing objects. 
│   ├── boilerplate.py : Boilerplate example. 
│   ├── cfexercises1.py : Control flow exercises. 
│   ├── cfexercises2.py : Control flow 'foo_x' exercises to run as script or importable module. 
│   ├── control_flow.py : Some functions exemplifying the use of control statements.
│   ├── debugme.py : Sample script to understand debugger. 
│   ├── dictionary.py : Populate dictionary from taxa list to match species to order names. 
│   ├── lc1.py : List comprehensions and conventional loops for bird species. 
│   ├── lc2.py : List comprehensions and conventional loops of average UK rainfall for 1910 by month 
│   ├── loops.py : Loop examples. 
│   ├── oaks_debugme.py : Usng doctests to confirm working function and modifying script to handle typos.Sample script to understand debugger. 
│   ├── oaks.py : Loop and list comprehension exercises to create a set of oak species from a list of tree species. 
│   ├── __pycache__
│   │   ├── boilerplate.cpython-35.pyc
│   │   ├── cfexercises2.cpython-35.pyc
│   │   ├── control_flow.cpython-35.pyc
│   │   ├── dictionary.cpython-35.pyc
│   │   └── using_name.cpython-35.pyc
│   ├── scope.py : Script to test local and global variables. 
│   ├── sys.argv.py : Script to understand 'sys.argv' function. 
│   ├── test_control_flow.py : Some functions exemplifying the use of control statements.
│   ├── tuple.py : Script to print tuples from birds on seperate lines.
│   └── using_name.py : Script to test __name__ = __main__ function. 
├── Data
│   ├── bodymass.csv : Body mass (kg) of bird species opened in basic_csv.py 
│   ├── JustOaksData.csv : Output data file from oaks_debugme.py script to contain oak species from a list of trees.
│   ├── Seqs_input.fasta : Input fasta file containing genome sequences used in align_seqs.py script to find best alignement and base match score.
│   ├── testcsv.csv : Input .csv file containing species, infraorders, families, distribution and body mass to manipulate in written output file as part of the testcsv.csv exercise.
│   └── TestOaksData.csv : Input data file of tree species used in the oaks_debugme.py script.
├── README
├── Results
└── Sandbox
    ├── testout.txt : Test file to save elements of a list generated in basic_io.py script.
    ├── testp.p : Binary file to be pickle dictionary contents in basic_io.py script.
    └── test.txt : Input file to be manipulated in basic_io.py script.

5 directories, 33 files
**********************************************************************

Found following files in results directory: Best_Match.txt...
Found 19 code files: lc2.py, boilerplate.py, basic_csv.py, cfexercises2.py, sys.argv.py, dictionary.py, debugme.py, scope.py, cfexercises1.py, tuple.py, basic_io.py, lc1.py, oaks_debugme.py, oaks.py, loops.py, using_name.py, align_seqs.py, control_flow.py, test_control_flow.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file lc2.py...

File contents are:
**********************************************************************
#!usr/bin/env python3
""" List comprehensions and conventional loops of average UK rainfall for 1910 by month """
__author__= 'Eva Linehan (eva.linehan18@imperial.ac.uk)'
__version__ = 0.01
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'

# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )


# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.

Rainfallover100mm = [x for x in rainfall if x[1]>=100]
print (Rainfallover100mm)

# (2) Use a list comprehension to create a list of just month names where the
# amount of rain was less than 50 mm. 

Rainfallless50mm = [x for x in rainfall if x[1]<50]
print (Rainfallless50mm)

# (3) Now do (1) and (2) using conventional loops (you can choose to do 
# this before 1 and 2 !). 

#Loop for (1)           
Rainfallover100mm=[]
Item=list(rainfall)
for x in rainfall:
    if x[1]>100:
        Rainfallover100mm.append(x)
print(Rainfallover100mm)


#Loop for (2)
Rainfallless50mm=[]
Item=list(rainfall)
for x in rainfall:
    if x[1]<50:
        Rainfallless50mm.append(x)
print(Rainfallless50mm)


# ANNOTATE WHAT EVERY BLOCK OR IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS
**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
[('MAR', 49.9), ('SEP', 27.0)]
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
[('MAR', 49.9), ('SEP', 27.0)]

**********************************************************************

Code ran without errors

Time consumed = 0.01342s

======================================================================
Inspecting script file boilerplate.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Boilerplate example. """
__appname__ = '[boilerplate.py]'
__author__  = 'Eva Linehan (eval2495@gmail.com)'
__version__ = '0.0.1'
__licence__ = 'Test'

## imports ##
import sys # module to interface our program with the operating system

## constants ##

## functions ##
def main(argv):
    """ Main entry point of the program """
    print ('This is a boilerplate')
    return 0

if __name__ =="__main__":
    print('This program is being run by itself')
    status = main(sys.argv)
    sys.exit("Done!")
**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This program is being run by itself
This is a boilerplate

**********************************************************************

Encountered error:
Done!

======================================================================
Inspecting script file basic_csv.py...

File contents are:
**********************************************************************
#!usr/bin/env python3
""" Importing, reading and writing .csv files in python. """
__author__= 'Eva Linehan (eva.linehan18@imperial.ac.uk)'
__version__ = 0.01
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'

# Read a file containing:
# 'Species','Infraorder', 'Family', 'Distribution','Body mass male (Kg)'
f = open('../Data/testcsv.csv','r')

csvread = csv.reader(f)
temp = []
for row in csvread:
    temp.append(tuple(row))
    print (row)
    print("The species is",row[0])

f.close()

# CSVREAD TO READ OPEN FILE (F). TEMP IS THE FRANE WHERE INFO WILL GO. ONCE IT IS ORGANIZED (IN THIS CASE TUPLE ROW AND PRINT) 

# write a file containing only species name and Body mass
f = open ('../Data/testcsv.csv','r')
g = open ('../Data/bodymass.csv','w')

csvread = csv.reader(f)
csvwrite = csv.writer(g)
for row in csvread:
    print(row)
    csvwrite.writerow([row[0], row[4]])

f.close()
g.close()
**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Traceback (most recent call last):
  File "basic_csv.py", line 12, in <module>
    csvread = csv.reader(f)
NameError: name 'csv' is not defined

======================================================================
Inspecting script file cfexercises2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Control flow 'foo_x' exercises to run as script or importable module. """

__author__  = 'Eva Linehan (eval2496@gmail.com)'
__version__ = '0.0.1'
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'

import sys

def foo1(x):
    """ Computes value (x) to the power of 0.5"""
    return x ** 0.5

def foo2(x, y):
    """ If x is greater than y, returns x. Otherwise y will be returned"""
    if x > y:
        return x
    return y

def foo3(x, y, z):
    """ Changes position of variables depending on value. If x is bigger than y, variables are swapped. If y is greater than z, the variables are swapped"""
    if x > y:
        tmp = y
        y = x
        x = tmp
    if y > z:
        tmp = z
        z = y
        y = tmp
    return [x, y, z]

def foo4(x=2):
    """ Calculates factorials iteratively by multiplying result by successively larger numbers in the range"""
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return result

def foo5(x): # a recursive function
    """ Calculates factorials recursively """
    if x == 1:
        return 1
    return x * foo5(x - 1)

def foo6(x): # Calculate the factorial of x in a different way
    """ Calculates factorials iteratively by multiplying x by x-1 and so on as long as x>=1"""
    facto = 1
    while x >= 1:
        facto = facto * x
        x = x - 1
    return facto

def main(argv):
    print(foo1(6))
    print(foo2(3,3))
    print(foo3(5,4,6))
    print(foo4(12))
    print(foo5(20))
    print(foo6(9))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing cfexercises2.py...

cfexercises2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
2.44948974278
3
[4, 5, 6]
479001600
2432902008176640000
362880

**********************************************************************

Code ran without errors

Time consumed = 0.01285s

======================================================================
Inspecting script file sys.argv.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Script to understand 'sys.argv' function. """
__author__= 'Eva Linehan (eva.linehan18@imperial.ac.uk)'
__version__ = 0.01
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'

import sys
print ("This is the name of the script: ", sys.argv[0])
print ("Number of arguments: ", len(sys.argv))
print ("The arguments are: ", str(sys.argv))
**********************************************************************

Testing sys.argv.py...

sys.argv.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
('This is the name of the script: ', 'sys.argv.py')
('Number of arguments: ', 1)
('The arguments are: ', "['sys.argv.py']")

**********************************************************************

Code ran without errors

Time consumed = 0.01517s

======================================================================
Inspecting script file dictionary.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Populate dictionary from taxa list to match species to order names. """
__author__= 'Eva Linehan (eva.linehan18@imperial.ac.uk)'
__version__ = 0.01
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'


taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

# Write a short python script to populate a dictionary called taxa_dic 
# derived from  taxa so that it maps order names to sets of taxa. 
# E.g. 'Chiroptera' : set(['Myotis lucifugus']) etc. 

""" Dictionary comprehension in which a set is created to add species to the matching order. """
taxa_dict = {x[1] : set([y[0] for y in taxa if y[1] == x[1]]) for x in taxa}
print(taxa_dict)




**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
{'Rodentia': set(['Peromyscus crinitus', 'Mus domesticus', 'Gerbillus henleyi', 'Cleithrionomys rutilus']), 'Afrosoricida': set(['Microgale dobsoni', 'Microgale talazaci']), 'Chiroptera': set(['Myotis lucifugus']), 'Carnivora': set(['Arctocephalus gazella', 'Lyacon pictus', 'Canis lupus'])}

**********************************************************************

Code ran without errors

Time consumed = 0.01318s

======================================================================
Inspecting script file debugme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Sample script to understand debugger. """
__author__= 'Eva Linehan (eva.linehan18@imperial.ac.uk)'
__version__ = 0.01
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'

def createabug(x=0):
    """ Function to divide x ^^3 by 0 which does not compute. """
    y=x**3
    import ipdb; ipdb.set_trace()
    z=0
    y=y/z
    return y

createabug(2)
**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
]0;IPython: Week2/Code> [0;32m/home/mhasoba/Documents/Teaching/IC_CMEE/2018-19/Coursework/StudentRepos/EvaLineham_NA/Week2/Code/debugme.py[0m(12)[0;36mcreateabug[0;34m()[0m
[0;32m     10 [0;31m    [0my[0m[0;34m=[0m[0mx[0m[0;34m**[0m[0;36m3[0m[0;34m[0m[0m
[0m[0;32m     11 [0;31m    [0;32mimport[0m [0mipdb[0m[0;34m;[0m [0mipdb[0m[0;34m.[0m[0mset_trace[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0m
[0m[0;32m---> 12 [0;31m    [0mz[0m[0;34m=[0m[0;36m0[0m[0;34m
**********************************************************************

Code ran without errors

Time consumed = 0.37483s

======================================================================
Inspecting script file scope.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Script to test local and global variables. """
__author__= 'Eva Linehan (eva.linehan18@imperial.ac.uk)'
__version__ = 0.01
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'


## Try this first

_a_global = 10

def a_function():
    """ Prints defined variables within function"""
    _a_global = 5
    _a_local = 4
    print ("Inside the function, the value is", _a_global)
    print ("Inside the function, the value is", _a_local)
    return None

a_function()
print("Outside the function, the value is", _a_global)
# Prints global variable 

## Now try this

_a_global = 10

def a_function():
    """ Prints defined variables within function """
    global _a_global #This variable can now be used inside and outside the function
    _a_global = 5
    _a_local = 4
    print ("Inside the function, the value is", _a_global)
    print ("Inside the function, the value is", _a_local)
    return None

a_function()
print("Outside the function, the value is", _a_global)
**********************************************************************

Testing scope.py...

scope.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
('Inside the function, the value is', 5)
('Inside the function, the value is', 4)
('Outside the function, the value is', 10)
('Inside the function, the value is', 5)
('Inside the function, the value is', 4)
('Outside the function, the value is', 5)

**********************************************************************

Code ran without errors

Time consumed = 0.01819s

======================================================================
Inspecting script file cfexercises1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Control flow exercises. """
__author__= 'Eva Linehan (eva.linehan18@imperial.ac.uk)'
__version__ = 0.01
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'


for i in range (3, 17):
    print ('hello')

for j in range(12):
    if j % 3 == 0:
        print('hello')

for j in range(15):
    if j % 5 ==3:
        print ('hello')

z = 0
while z!= 15:
    print ('hello')
    z = z + 3

z = 12
while z < 100:
    if z == 31:
        for k in range(7):
            print ('hello')
    elif z == 18:
        print ('hello')
    z = z + 1
**********************************************************************

Testing cfexercises1.py...

cfexercises1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello

**********************************************************************

Code ran without errors

Time consumed = 0.01501s

======================================================================
Inspecting script file tuple.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Script to print tuples from birds on seperate lines """
__author__= 'Eva Linehan (eva.linehan18@imperial.ac.uk)'
__version__ = 0.01
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'

birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line or output block by species 
# Hints: use the "print" command! You can use list comprehensions!

#Each tuple is mapped as a string and joined to a newline character to print on individual lines. 
bird2 = map(str,birds)
print('\n'.join(bird2))


**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
('Passerculus sandwichensis', 'Savannah sparrow', 18.7)
('Delichon urbica', 'House martin', 19)
('Junco phaeonotus', 'Yellow-eyed junco', 19.5)
('Junco hyemalis', 'Dark-eyed junco', 19.6)
('Tachycineata bicolor', 'Tree swallow', 20.2)

**********************************************************************

Code ran without errors

Time consumed = 0.01569s

======================================================================
Inspecting script file basic_io.py...

File contents are:
**********************************************************************
#!usr/bin/env python3
""" Example of printing input files, generating output files and storing objects. """
__author__= 'Eva Linehan (eva.linehan18@imperial.ac.uk)'
__version__ = 0.01
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'


##############################
#FILE INPUT
##############################
# Open a file for reading - CREATING AN OBJECT
f=open('../Sandbox/test.txt','r')
# use "implicit" for loop:
# if the object is a file, python will cycle over lines
for line in f: 
    print(line)
# OPENS OBJECT F IN LOOP
# close the file
f.close ()

# Same example, skip the blank line

f = open('../Sandbox/test.txt','r')
for line in f:
    if len(line.strip()) > 0:
        print(line)
f.close()


##############################
#FILE OUTPUT
##############################
# Save the elements of a list to a file

list_to_save = range(100)

f = open('../Sandbox/testout.txt','w')
for i in list_to_save:
    f.write(str(i) + '\n')

f.close ()


##############################
# STORING OBJECTS
##############################
# To save an object (even complex) for later use

my_dictionary = {"a key": 10, "another key": 11}

import pickle


f = open('../Sandbox/testp.p', 'wb')

pickle.dump(my_dictionary, f)

f.close()

# 'testp.p' is binary file, 'as f' is the variable or alias in this case.
# pickle.dump (variable, location) 

with open('../Sandbox/testp.p', 'wb') as f:   
# with command autocloses. 
    pickle.dump(my_dictionary, f)

print("Done")

## Load the data again
f = open('../Sandbox/testp.p','rb')
another_directory = pickle.load(f)
f.close()


with open('../Sandbox/testp.p', "rb") as f:
    another_directory = pickle.load(f)  


print(another_directory)
**********************************************************************

Testing basic_io.py...

basic_io.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
First Line

Second Line

 

Third Line

 

Fourth Line

First Line

Second Line

Third Line

Fourth Line

Done
{'another key': 11, 'a key': 10}

**********************************************************************

Code ran without errors

Time consumed = 0.01807s

======================================================================
Inspecting script file lc1.py...

File contents are:
**********************************************************************
#!usr/bin/env python3
""" List comprehensions and conventional loops for bird species. """
__author__= 'Eva Linehan (eva.linehan18@imperial.ac.uk)'
__version__ = 0.01
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'

birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),)


#(1) Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively.

latin_names = [name[0] for name in birds]
print (latin_names)

common_names = [name[1] for name in birds]
print (common_names)

body_mass = [name[2] for name in birds]
print (body_mass)


# (2) Now do the same using conventional loops (you can shoose to do this
# before 1 !).

latin_names, common_names, body_mass = ([] for i in range (3))
for name in birds:
    latin_names.append(name[0])
    common_names.append(name[1])
    body_mass.append(name[2])
#for each list, the selected element in each subset (0th,1st,2nd) is added
print (latin_names)
print (common_names)
print (body_mass)


# ANNOTATE WHAT EVERY BLOCK OR IF NECESSARY, LINE IS DOING!

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS.
**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]

**********************************************************************

Code ran without errors

Time consumed = 0.01412s

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:
**********************************************************************
#!usr/bin/env python3
""" Missing oaks problem.

Usng doctests to confirm working function and modifying script to handle typos.

 """
__author__= 'Eva Linehan (eva.linehan18@imperial.ac.uk)'
__version__ = 0.01
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'

import csv
import sys
import pdb
import doctest

#Define function
def is_an_oak(name):
    """ Returns True if genus name is 'quercus'

    >>> is_an_oak('quercuss robur')
    False

    >>> is_an_oak('fraxinus excelsior')
    False

    >>> is_an_oak('pinus sylvertris')
    False

    >>> is_an_oak('quercus cerris')
    True

    """
    return name.lower().split(' ')[0]=='quercus'
    # .split seperates string by the space (in between genus and species) to ensure the first element (species in this case) will be quercus.

def main(argv): 
    """ Removing headers in taxa, print the genus of trees with 'FOUND AN OAK' for any of the variables from is_an_oak. For output file 'JustOaksData.csv' print headers in first row followed by oak species"""    
    f = open('../Data/TestOaksData.csv','r')
    g = open('../Data/JustOaksData.csv','w')
    taxa = csv.reader(f)
    headers = next(taxa, None) #Skip the headers
    csvwrite = csv.writer(g)
    oaks = set()
    c = 0
    for row in taxa:
        c += 1
        print(row)
        print ("The genus is: ") 
        print(row[0])
        if is_an_oak(row[0]):
            print('FOUND AN OAK!\n')
        if c == 1:
            if headers:
                csvwrite.writerow(headers)
    csvwrite.writerow([row[0], row[1]])   
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit (status)

doctest.testmod()
**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['Quercus', ' robur']
The genus is: 
Quercus
FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus
['Pinus', ' sylvestris']
The genus is: 
Pinus
['Quercus', ' cerris']
The genus is: 
Quercus
FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus
FOUND AN OAK!


**********************************************************************

Code ran without errors

Time consumed = 0.04283s

======================================================================
Inspecting script file oaks.py...

File contents are:
**********************************************************************
#!usr/bin/env python3
""" Loop and list comprehension exercises to create a set of oak species from a list of tree species. """
__author__= 'Eva Linehan (eva.linehan18@imperial.ac.uk)'
__version__ = 0.01
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'

## Finds just those taxa that are oak trees from a list of species

taxa = [ 'Quercus robur',
         'Fraxinus excelsior',
         'Pinus sylvestris',
         'Quercus cerris',
         'Quercus petraea']

def is_an_oak(name):
    """ Function to return just oak species in lower case. """
    return name.lower().startswith('quercus')

## Using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species)
print (oaks_loops)

## Using list comprehensions
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)

##Get names in upper case using loops
oaks_loops = set ()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add (species.upper())
print(oaks_loops)

##Get names in UPPER CASE using list comprehensions
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)
**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
set(['Quercus robur', 'Quercus cerris', 'Quercus petraea'])
set(['Quercus robur', 'Quercus cerris', 'Quercus petraea'])
set(['QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'])
set(['QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'])

**********************************************************************

Code ran without errors

Time consumed = 0.01398s

======================================================================
Inspecting script file loops.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Loop examples. """
__author__= 'Eva Linehan (eva.linehan18@imperial.ac.uk)'
__version__ = 0.01
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'

for i in range(5):
    print(i)

my_list = [0, 2, "geronimo!", 3.0, True, False]
for k in my_list:
    print(k)

total = 0
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total = total + s
    print(total)

# WHILE loops  in Python
z = 0
while z < 100:
    z = z + 1
    print(z)

b = True
while b:
    print("GERONIMO! infinite loop! ctrl+c to stop!")
**********************************************************************

Testing loops.py...

loops.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c
**********************************************************************

Code ran without errors

Time consumed = 10.49256s

======================================================================
Inspecting script file using_name.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Script to test __name__ = __main__ function. """
__author__= 'Eva Linehan (eva.linehan18@imperial.ac.uk)'
__version__ = 0.01
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'

# Filename: using_name.py

if __name__ == '__main__':
    print('This program is being run by itself')
else:
    print('I am being imported from another module')
    
**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This program is being run by itself

**********************************************************************

Code ran without errors

Time consumed = 0.07384s

======================================================================
Inspecting script file align_seqs.py...

File contents are:
**********************************************************************
#!usr/bin/env python3
""" Aligning DNA sequences and assigning a score based on the start position and number of base matches. """
__author__= 'Eva Linehan (eva.linehan18@imperial.ac.uk)'
__version__ = 0.01
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'
 
# Sequences in input file
#seq2 = "ATCGCCGGATTACGGG"
#seq1 = "CAATTCGGAT"

import sys
""" 
Processes DNA sequences from .fasta file to print best alignment and score in .txt file.
"""
seq_dict = {}
with open("../Data/Seqs_input.fasta") as f:
    for line in f:
        if line.startswith(">"):
            key = line.split(">")[-1].rstrip()
            # For header, file title is printed by returning the last item in the line with no trailing characters
        else:
            if key in seq_dict.keys():
                seq_dict[key] += line.rstrip() 
            # Remove trailing characters from sequence and add to key.
            else:
                seq_dict[key] = line.rstrip()
print(seq_dict)

seq1 = seq_dict['Seq1']
seq2 = seq_dict['Seq2']

     
# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

## A function that computes a score by returning the number of matches starting
## from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

### Test the function with some example starting points:
### calculate_score(s1, s2, l1, l2, 0)
### calculate_score(s1, s2, l1, l2, 1)
### calculate_score(s1, s2, l1, l2, 5)

### now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z 
print(my_best_align)
print(s1)
print("Best score:", my_best_score)

# Save to an output
output = "../Results/Best_Match.txt"
outfile = '{}\n {}\nBest Score {}'.format(my_best_align, s1, my_best_score) #Formats output to print best alignment followed by best score
with open("../Results/Best_Match.txt", "w") as output:
    output.write(outfile)
print ("Done!")



**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
{'Seq2': 'CAATTCGGAT', 'Seq1': 'ATCGCCGGATTACGGG'}
-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5
 
.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2
 
..*---------
..CAATTCGGAT
ATCGCCGGATTACGGG
1
 
...--------*-
...CAATTCGGAT
ATCGCCGGATTACGGG
1
 
....*---------
....CAATTCGGAT
ATCGCCGGATTACGGG
1
 
.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG
2
 
......--***--*--
......CAATTCGGAT
ATCGCCGGATTACGGG
4
 
.......-*-*-***-
.......CAATTCGGAT
ATCGCCGGATTACGGG
5
 
........------**
........CAATTCGGAT
ATCGCCGGATTACGG
**********************************************************************

Code ran without errors

Time consumed = 0.05452s

======================================================================
Inspecting script file control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""Some functions exemplifying the use of control statements"""
# Replacing comments with docstrings which can be accessed at run time
__author__= 'Eva Linehan (eva.linehan18@imperial.ac.uk)'
__version__ = 0.01
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'

import sys # module to interface our program with the operating system

def even_or_odd(x): #If not specified, x should take value 0.
    """Find whether a number x is even or odd.""" 
    if x % 2 == 0: #Conditional
        return "%d is Even!" % x
    return "%d is Odd!" % x

def largest_divisor_five(x=120):
    """Find which is the largest divisor of x among 2,3,4,5."""
    largest = 0
    if x % 5 == 0:
        largest = 5
    elif x % 4 == 0: #means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else: # When all other (if, elif) conditions are not met
        return "No divisor found for %d!" % x # Each function can return a value or a variable.
    return "The largest divisor of %d is %d" % (x, largest)

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2, x): #  "range" returns a sequence of integers
        if x % i == 0:
          print("%d is not a prime: %d is a divisor" % (x, i)) #Print formatted text "%d %s %f %e" % (20,"30",0.0003,0.00003)

          return False
    print("%d is a prime!" % x)
    return True 

def find_all_primes(x=22):
    """Find all the primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
      if is_prime(i):
        allprimes.append(i)
    print("There are %d primes between 2 and %d" % (len(allprimes), x))
    return allprimes

def main(argv):
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is 
**********************************************************************

Code ran without errors

Time consumed = 0.01444s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""Some functions exemplifying the use of control statements"""
__author__  = 'Eva Linehan (eval2496@gmail.com)'
__version__ = '0.0.1'
__date__ = 'Oct 2018'
__licence__ = 'Inclass practical'


import sys # module to interface our program with the operating system
import doctest


def even_or_odd(x=0): #If not specified, x should take value 0.
    """ Find whether a number x is even or odd.

    >>> even_or_odd(10)
    '10 is Even!'
    
    >>> even_or_odd(5)
    '5 is Odd!'
 
    whenever a float is provided, then the closest integer is used:
    >>> even_or_odd(3.2)
    '3 is Odd!'

    >>> even_or_odd(-2)
    '-2 is Even!'

    """ 
    # Find whether a number x is even or odd.
    if x % 2 == 0: #Conditional
        return "%d is Even!" % x
    return "%d is Odd!" % x

# Define function to be tested
def largest_divisor_five(x=120):
    """Find which is the largest divisor of x among 2,3,4,5."""
    largest = 0
    if x % 5 == 0:
        largest = 5
    elif x % 4 == 0: #means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else: # When all other (if, elif) conditions are not met
        return "No divisor found for %d!" % x # Each function can return a value or a variable.
    return "The largest divisor of %d is %d" % (x, largest)

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2, x): #  "range" returns a sequence of integers
        if x % i == 0:
          print("%d s not a prime: %d is a divisor" % (x, i)) #Print formatted text "%d %s %f %e" % (20,"30",0.0003,0.00003)

          return False
    print("%d is a prime!" % x)
    return True 

def find_all_primes(x=22):
    """Find all the primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
      if is_prime(i):
        allprimes.append(i)
    print("There are %d primes between 2 and %d" % (len(allprimes), x))
    return allprimes

############ SUPRESSED ##############
#def main(argv):
 #   print(even_or_odd(22))
 #   print(even_or_odd(33))
 #   print(largest_divisor_five(120))
 #   print(largest_divisor_five(121))
 #   print(is_prime(60))
 #   print(is_prime(59))
 #   print(find_all_primes(100))
 #   return 0
#
##if (__name__ == "__main__"):
 #   status = main(sys.argv)
 #   sys.exit(status)
############ SUPRESSED ################

doctest.testmod()
**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.03957s

======================================================================
======================================================================
Finished running scripts

Ran into 2 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 99

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!